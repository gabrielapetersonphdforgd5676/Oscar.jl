###############################################################################
###############################################################################
### Standard constructions
###############################################################################
###############################################################################
@doc raw"""
    birkhoff_polytope(n::Integer, even::Bool = false)

Construct the Birkhoff polytope of dimension $n^2$.

This is the polytope of $n \times n$ stochastic matrices (encoded as row vectors of
length $n^2$), i.e., the matrices with non-negative real entries whose row and column
entries sum up to one. Its vertices are the permutation matrices.

Use `even = true` to get the vertices only for the even permutation matrices.

# Examples
```jldoctest
julia> b = birkhoff_polytope(3)
Polyhedron in ambient dimension 9

julia> vertices(b)
6-element SubObjectIterator{PointVector{QQFieldElem}}:
 [1, 0, 0, 0, 1, 0, 0, 0, 1]
 [0, 1, 0, 1, 0, 0, 0, 0, 1]
 [0, 0, 1, 1, 0, 0, 0, 1, 0]
 [1, 0, 0, 0, 0, 1, 0, 1, 0]
 [0, 1, 0, 0, 0, 1, 1, 0, 0]
 [0, 0, 1, 0, 1, 0, 1, 0, 0]
```
"""
birkhoff_polytope(n::Integer; even::Bool = false) = polyhedron(Polymake.polytope.birkhoff(n, Int(even), group=true))



@doc raw"""
    pyramid(P::Polyhedron, z::Number = 1)

Make a pyramid over the given polyhedron `P`.

The pyramid is the convex hull of the input polyhedron `P` and a point `v`
outside the affine span of `P`. For bounded polyhedra, the projection of `v` to
the affine span of `P` coincides with the vertex barycenter of `P`. The scalar `z`
is the distance between the vertex barycenter and `v`.

# Examples
```jldoctest
julia> c = cube(2)
Polyhedron in ambient dimension 2

julia> vertices(pyramid(c,5))
5-element SubObjectIterator{PointVector{QQFieldElem}}:
 [-1, -1, 0]
 [1, -1, 0]
 [-1, 1, 0]
 [1, 1, 0]
 [0, 0, 5]
```
"""
function pyramid(P::Polyhedron{T}, z::Number=1) where T<:scalar_types
   pm_in = pm_object(P)
   has_group = Polymake.exists(pm_in, "GROUP")
   return Polyhedron{T}(Polymake.polytope.pyramid(pm_in, z, group=has_group))
end



@doc raw"""
    bipyramid(P::Polyhedron, z::Number = 1, z_prime::Number = -z)

Make a bipyramid over a pointed polyhedron `P`.

The bipyramid is the convex hull of the input polyhedron `P` and two apexes
(`v`, `z`), (`v`, `z_prime`) on both sides of the affine span of `P`. For bounded
polyhedra, the projections of the apexes `v` to the affine span of `P` is the
vertex barycenter of `P`.

# Examples
```jldoctest
julia> c = cube(2)
Polyhedron in ambient dimension 2

julia> vertices(bipyramid(c,2))
6-element SubObjectIterator{PointVector{QQFieldElem}}:
 [-1, -1, 0]
 [1, -1, 0]
 [-1, 1, 0]
 [1, 1, 0]
 [0, 0, 2]
 [0, 0, -2]

```
"""
function bipyramid(P::Polyhedron{T}, z::Number=1, z_prime::Number=-z)  where T<:scalar_types
   pm_in = pm_object(P)
   has_group = Polymake.exists(pm_in, "GROUP")
   return Polyhedron{T}(Polymake.polytope.bipyramid(pm_in, z, z_prime, group=has_group))
end

@doc raw"""
    normal_cone(P::Polyhedron, i::Int64)

Construct the normal cone to `P` at the `i`-th vertex of `P`.

The normal cone at a face is generated by all the inner normals of `P` that
attain their minimum at the `i`-th vertex.

# Examples
Build the normal cones at the first vertex of the square (in this case [-1,-1]).
```jldoctest
julia> square = cube(2)
Polyhedron in ambient dimension 2

julia> vertices(square)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [-1, -1]
 [1, -1]
 [-1, 1]
 [1, 1]

julia> nc = normal_cone(square, 1)
Polyhedral cone in ambient dimension 2

julia> rays(nc)
2-element SubObjectIterator{RayVector{QQFieldElem}}:
 [1, 0]
 [0, 1]
```
"""
function normal_cone(P::Polyhedron{T}, i::Int64) where T<:scalar_types
    @req 1 <= i <= nvertices(P) "Vertex index out of range"
    bigobject = Polymake.polytope.normal_cone(pm_object(P), Set{Int64}([i-1]))
    return Cone{T}(bigobject)
end


@doc raw"""
    orbit_polytope(V::AbstractCollection[PointVector], G::PermGroup)

Construct the convex hull of the orbit of one or several points (given row-wise
in `V`) under the action of `G`.

# Examples
This will construct the $3$-dimensional permutahedron:
```jldoctest
julia> V = [1 2 3];

julia> G = symmetric_group(3);

julia> P = orbit_polytope(V, G)
Polyhedron in ambient dimension 3

julia> vertices(P)
6-element SubObjectIterator{PointVector{QQFieldElem}}:
 [1, 2, 3]
 [1, 3, 2]
 [2, 1, 3]
 [2, 3, 1]
 [3, 1, 2]
 [3, 2, 1]
```
"""
function orbit_polytope(V::AbstractCollection[PointVector], G::PermGroup)
   Vhom = stack(homogenized_matrix(V, 1), nothing)
   @req size(Vhom, 2) == degree(G) + 1 "Dimension of points and group degree need to be the same"
   generators = PermGroup_to_polymake_array(G)
   pmGroup = Polymake.group.PermutationAction(GENERATORS=generators)
   pmPolytope = Polymake.polytope.orbit_polytope(Vhom, pmGroup)
   return Polyhedron{QQFieldElem}(pmPolytope)
end

@doc raw"""
    cube([::Type{T} = QQFieldElem,] d::Int , [l::Rational = -1, u::Rational = 1])

Construct the $[l,u]$-cube in dimension $d$.

# Examples
In this example the 5-dimensional unit cube is constructed to ask for one of its
properties:
```jldoctest
julia> C = cube(5,0,1);

julia> normalized_volume(C)
120
```
"""
cube(::Type{T}, d::Int) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.cube{scalar_type_to_polymake[T]}(d))
cube(d::Int) = cube(QQFieldElem, d)
cube(::Type{T}, d::Int, l, u) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.cube{scalar_type_to_polymake[T]}(d, u, l))
cube(d::Int, l, u) = cube(QQFieldElem, d, l, u)

@doc raw"""
    tetrahedron()

Construct the regular tetrahedron, one of the Platonic solids.
"""
tetrahedron() = polyhedron(Polymake.polytope.tetrahedron());

@doc raw"""
    dodecahedron()

Construct the regular dodecahedron, one out of two Platonic solids.
"""
dodecahedron() = polyhedron(Polymake.polytope.dodecahedron());

@doc raw"""
    icosahedron()

Construct the regular icosahedron, one out of two exceptional Platonic solids.
"""
icosahedron() = polyhedron(Polymake.polytope.icosahedron());

@doc raw"""
    johnson_solid(i::Int)

Construct the `i`-th proper Johnson solid.

A Johnson solid is a 3-polytope whose facets are regular polygons, of various gonalities.
It is proper if it is not an Archimedean solid.  Up to scaling there are exactly 92 proper Johnson solids.
"""
johnson_solid(index::Int) = polyhedron(Polymake.polytope.johnson_solid(index));

@doc raw"""
    regular_24_cell()

Construct the regular 24-cell, one out of three exceptional regular 4-polytopes.
"""
regular_24_cell() = polyhedron(Polymake.polytope.regular_24_cell());

@doc raw"""
    regular_120_cell()

Construct the regular 120-cell, one out of three exceptional regular 4-polytopes.
"""
regular_120_cell() = polyhedron(Polymake.polytope.regular_120_cell());

@doc raw"""
    regular_600_cell()

Construct the regular 600-cell, one out of three exceptional regular 4-polytopes.
"""
regular_600_cell() = polyhedron(Polymake.polytope.regular_600_cell());

"""
    newton_polytope(poly::Polynomial)

Compute the Newton polytope of the multivariate polynomial `poly`.

# Examples
```jldoctest
julia> S, (x, y) = polynomial_ring(ZZ, ["x", "y"])
(Multivariate polynomial ring in 2 variables over ZZ, ZZMPolyRingElem[x, y])

julia> f = x^3*y + 3x*y^2 + 1
x^3*y + 3*x*y^2 + 1

julia> NP = newton_polytope(f)
Polyhedron in ambient dimension 2

julia> vertices(NP)
3-element SubObjectIterator{PointVector{QQFieldElem}}:
 [3, 1]
 [1, 2]
 [0, 0]
```
"""
function newton_polytope(f)
    exponents = reduce(hcat, Oscar.AbstractAlgebra.exponent_vectors(f))'
    convex_hull(exponents)
end


polyhedron(H::Halfspace{T}) where T<:scalar_types = polyhedron(T, normal_vector(H), negbias(H))

polyhedron(H::Halfspace{Union{QQFieldElem, nf_elem}}) = polyhedron(nf_elem, normal_vector(H), negbias(H))

polyhedron(H::Hyperplane{T}) where T<:scalar_types = polyhedron(T, nothing, (normal_vector(H), [negbias(H)]))

polyhedron(H::Hyperplane{Union{QQFieldElem, nf_elem}}) = polyhedron(nf_elem, nothing, (normal_vector(H), [negbias(H)]))

@doc raw"""
    intersect(P::Polyhedron, Q::Polyhedron)

Return the intersection $P \cap Q$ of `P` and `Q`.

# Examples
The positive orthant of the plane is the intersection of the two halfspaces with
$x≥0$ and $y≥0$ respectively.
```jldoctest
julia> UH1 = convex_hull([0 0],[1 0],[0 1]);

julia> UH2 = convex_hull([0 0],[0 1],[1 0]);

julia> PO = intersect(UH1, UH2)
Polyhedron in ambient dimension 2

julia> rays(PO)
2-element SubObjectIterator{RayVector{QQFieldElem}}:
 [1, 0]
 [0, 1]
```
"""
function intersect(P::Polyhedron{T}...) where T<:scalar_types
    pmo = [pm_object(p) for p in P]
    return Polyhedron{T}(Polymake.polytope.intersection(pmo...))
end
intersect(P::AbstractVector{Polyhedron{T}}) where T<:scalar_types = intersect(P...)


@doc raw"""
    minkowski_sum(P::Polyhedron, Q::Polyhedron)

Return the Minkowski sum $P + Q = \{ x+y\ |\ x∈P, y∈Q\}$ of `P` and `Q`.

# Examples
The Minkowski sum of a square and the 2-dimensional cross-polytope is an
octagon:
```jldoctest
julia> P = cube(2);

julia> Q = cross_polytope(2);

julia> M = minkowski_sum(P, Q)
Polyhedron in ambient dimension 2

julia> nvertices(M)
8
```
"""
function minkowski_sum(P::Polyhedron{T}, Q::Polyhedron{T}; algorithm::Symbol=:standard) where T<:scalar_types
   if algorithm == :standard
      return Polyhedron{T}(Polymake.polytope.minkowski_sum(pm_object(P), pm_object(Q)))
   elseif algorithm == :fukuda
      return Polyhedron{T}(Polymake.polytope.minkowski_sum_fukuda(pm_object(P), pm_object(Q)))
   else
      throw(ArgumentError("Unknown minkowski sum `algorithm` argument: $algorithm"))
   end
end



@doc raw"""
    product(P::Polyhedron, Q::Polyhedron)

Return the Cartesian product of `P` and `Q`.

# Examples
The Cartesian product of a triangle and a line segment is a triangular prism.
```jldoctest
julia> T=simplex(2)
Polyhedron in ambient dimension 2

julia> S=cube(1)
Polyhedron in ambient dimension 1

julia> length(vertices(product(T,S)))
6
```
"""
product(P::Polyhedron{T}, Q::Polyhedron{T}) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.product(pm_object(P), pm_object(Q)))

@doc raw"""
    *(P::Polyhedron, Q::Polyhedron)

Return the Cartesian product of `P` and `Q` (see also `product`).

# Examples
The Cartesian product of a triangle and a line segment is a triangular prism.
```jldoctest
julia> T=simplex(2)
Polyhedron in ambient dimension 2

julia> S=cube(1)
Polyhedron in ambient dimension 1

julia> length(vertices(T*S))
6
```
"""
*(P::Polyhedron{T}, Q::Polyhedron{T}) where T<:scalar_types = product(P,Q)

@doc raw"""
    convex_hull(P::Polyhedron, Q::Polyhedron)

Return the convex_hull of `P` and `Q`.

# Examples
The convex hull of the following two line segments in $R^3$ is a tetrahedron.
```jldoctest
julia> L₁ = convex_hull([-1 0 0; 1 0 0])
Polyhedron in ambient dimension 3

julia> L₂ = convex_hull([0 -1 0; 0 1 0])
Polyhedron in ambient dimension 3

julia> T=convex_hull(L₁,L₂);

julia> f_vector(T)
2-element Vector{ZZRingElem}:
 4
 4
```
"""
function convex_hull(P::Polyhedron{T}...) where T<:scalar_types
    pmo = [pm_object(p) for p in P]
    return Polyhedron{T}(Polymake.polytope.conv(pmo...))
end
convex_hull(P::AbstractVector{Polyhedron{T}}) where T<:scalar_types = convex_hull(P...)



#TODO: documentation  + extend to different fields.

@doc raw"""
    +(P::Polyhedron, Q::Polyhedron)

Return the Minkowski sum $P + Q = \{ x+y\ |\ x∈P, y∈Q\}$ of `P` and `Q` (see also `minkowski_sum`).

# Examples
The Minkowski sum of a square and the 2-dimensional cross-polytope is an
octagon:
```jldoctest
julia> P = cube(2);

julia> Q = cross_polytope(2);

julia> M = minkowski_sum(P, Q)
Polyhedron in ambient dimension 2

julia> nvertices(M)
8
```
"""
+(P::Polyhedron{T}, Q::Polyhedron{T}) where T<:scalar_types = minkowski_sum(P,Q)


#TODO: extend to different fields

@doc raw"""
    *(k::Int, Q::Polyhedron)

Return the scaled polyhedron $kQ = \{ kx\ |\ x∈Q\}$.

Note that `k*Q = Q*k`.

# Examples
Scaling an $n$-dimensional bounded polyhedron by the factor $k$ results in the
volume being scaled by $k^n$.
This example confirms the statement for the 6-dimensional cube and $k = 2$.
```jldoctest
julia> C = cube(6);

julia> SC = 2*C
Polyhedron in ambient dimension 6

julia> volume(SC)//volume(C)
64
```
"""
*(k::Int, P::Polyhedron{T}) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.scale(pm_object(P),k))


@doc raw"""
    *(P::Polyhedron, k::Int)

Return the scaled polyhedron $kP = \{ kx\ |\ x∈P\}$.

Note that `k*P = P*k`.

# Examples
Scaling an $n$-dimensional bounded polyhedron by the factor $k$ results in the
volume being scaled by $k^n$.
This example confirms the statement for the 6-dimensional cube and $k = 2$.
```jldoctest
julia> C = cube(6);

julia> SC = C*2
Polyhedron in ambient dimension 6

julia> volume(SC)//volume(C)
64
```
"""
*(P::Polyhedron{T},k::Int) where T<:scalar_types = k*P


@doc raw"""
    +(P::Polyhedron, v::AbstractVector)

Return the translation $P+v = \{ x+v\ |\ x∈P\}$ of `P` by `v`.

Note that `P+v = v+P`.

# Examples
We construct a polyhedron from its $V$-description. Shifting it by the right
vector reveals that its inner geometry corresponds to that of the 3-simplex.
```jldoctest
julia> P = convex_hull([100 200 300; 101 200 300; 100 201 300; 100 200 301]);

julia> v = [-100, -200, -300];

julia> S = P + v
Polyhedron in ambient dimension 3

julia> vertices(S)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [0, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 0, 1]
```
"""
function +(P::Polyhedron{T}, v::AbstractVector) where T<:scalar_types
    @req ambient_dim(P) == length(v) "Translation vector not correct dimension"
    return Polyhedron{T}(Polymake.polytope.translate(pm_object(P), Polymake.Vector{scalar_type_to_polymake[T]}(v)))
end


@doc raw"""
    +(v::AbstractVector, P::Polyhedron)

Return the translation $P+v = \{ x+v\ |\ x∈P\}$ of `P` by `v`.

Note that `P+v = v+P`.

# Examples
We construct a polyhedron from its $V$-description. Shifting it by the right
vector reveals that its inner geometry corresponds to that of the 3-simplex.
```jldoctest
julia> P = convex_hull([100 200 300; 101 200 300; 100 201 300; 100 200 301]);

julia> v = [-100, -200, -300];

julia> S = v + P
Polyhedron in ambient dimension 3

julia> vertices(S)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [0, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 0, 1]
```
"""
+(v::AbstractVector,P::Polyhedron{T}) where T<:scalar_types = P+v

@doc raw"""
    simplex([::Type{T} = QQFieldElem,] d::Int [,n::Rational])

Construct the simplex which is the convex hull of the standard basis vectors
along with the origin in $\mathbb{R}^d$, scaled by $n$.

# Examples
Here we take a look at the facets of the 7-simplex and a scaled 7-simplex:
```jldoctest
julia> s = simplex(7)
Polyhedron in ambient dimension 7

julia> facets(s)
8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the Halfspaces of R^7 described by:
-x₁ ≦ 0
-x₂ ≦ 0
-x₃ ≦ 0
-x₄ ≦ 0
-x₅ ≦ 0
-x₆ ≦ 0
-x₇ ≦ 0
x₁ + x₂ + x₃ + x₄ + x₅ + x₆ + x₇ ≦ 1

julia> t = simplex(7, 5)
Polyhedron in ambient dimension 7

julia> facets(t)
8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the Halfspaces of R^7 described by:
-x₁ ≦ 0
-x₂ ≦ 0
-x₃ ≦ 0
-x₄ ≦ 0
-x₅ ≦ 0
-x₆ ≦ 0
-x₇ ≦ 0
x₁ + x₂ + x₃ + x₄ + x₅ + x₆ + x₇ ≦ 5
```
"""
simplex(::Type{T}, d::Int, n) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.simplex{scalar_type_to_polymake[T]}(d,n))
simplex(d::Int, n) = simplex(QQFieldElem, d, n)
simplex(::Type{T}, d::Int) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.simplex{scalar_type_to_polymake[T]}(d))
simplex(d::Int) = simplex(QQFieldElem, d)


@doc raw"""
    cross_polytope([::Type{T} = QQFieldElem,] d::Int [,n::Rational])

Construct a $d$-dimensional cross polytope around origin with vertices located
at $\pm e_i$ for each unit vector $e_i$ of $R^d$, scaled by $n$.

# Examples
Here we print the facets of a non-scaled and a scaled 3-dimensional cross
polytope:
```jldoctest
julia> C = cross_polytope(3)
Polyhedron in ambient dimension 3

julia> facets(C)
8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the Halfspaces of R^3 described by:
x₁ + x₂ + x₃ ≦ 1
-x₁ + x₂ + x₃ ≦ 1
x₁ - x₂ + x₃ ≦ 1
-x₁ - x₂ + x₃ ≦ 1
x₁ + x₂ - x₃ ≦ 1
-x₁ + x₂ - x₃ ≦ 1
x₁ - x₂ - x₃ ≦ 1
-x₁ - x₂ - x₃ ≦ 1

julia> D = cross_polytope(3, 2)
Polyhedron in ambient dimension 3

julia> facets(D)
8-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the Halfspaces of R^3 described by:
x₁ + x₂ + x₃ ≦ 2
-x₁ + x₂ + x₃ ≦ 2
x₁ - x₂ + x₃ ≦ 2
-x₁ - x₂ + x₃ ≦ 2
x₁ + x₂ - x₃ ≦ 2
-x₁ + x₂ - x₃ ≦ 2
x₁ - x₂ - x₃ ≦ 2
-x₁ - x₂ - x₃ ≦ 2
```
"""
cross_polytope(::Type{T}, d::Int64, n) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.cross{scalar_type_to_polymake[T]}(d,n))
cross_polytope(d::Int64, n) = cross_polytope(QQFieldElem, d, n)
cross_polytope(::Type{T}, d::Int64) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.cross{scalar_type_to_polymake[T]}(d))
cross_polytope(d::Int64) = cross_polytope(QQFieldElem, d)

@doc raw"""
    platonic_solid(s)

Construct a Platonic solid with the name given by String `s` from the list
below.

# Arguments
- `s::String`: The name of the desired Archimedean solid.
    Possible values:
    - "tetrahedron" : Tetrahedron.
          Regular polytope with four triangular facets.
    - "cube" : Cube.
          Regular polytope with six square facets.
    - "octahedron" : Octahedron.
          Regular polytope with eight triangular facets.
    - "dodecahedron" : Dodecahedron.
          Regular polytope with 12 pentagonal facets.
    - "icosahedron" : Icosahedron.
          Regular polytope with 20 triangular facets.

# Examples
```jldoctest
julia> T = platonic_solid("icosahedron")
Polyhedron in ambient dimension 3 with nf_elem type coefficients

julia> nfacets(T)
20
```
"""
platonic_solid(s::String) = polyhedron(Polymake.polytope.platonic_solid(s))

@doc raw"""
    archimedean_solid(s)

Construct an Archimedean solid with the name given by String `s` from the list
below.  The polytopes are realized with floating point numbers and thus not
exact; Vertex-facet-incidences are correct in all cases.

# Arguments
- `s::String`: The name of the desired Archimedean solid.
    Possible values:
    - "truncated_tetrahedron" : Truncated tetrahedron.
          Regular polytope with four triangular and four hexagonal facets.
    - "cuboctahedron" : Cuboctahedron.
          Regular polytope with eight triangular and six square facets.
    - "truncated_cube" : Truncated cube.
          Regular polytope with eight triangular and six octagonal facets.
    - "truncated_octahedron" : Truncated Octahedron.
          Regular polytope with six square and eight hexagonal facets.
    - "rhombicuboctahedron" : Rhombicuboctahedron.
          Regular polytope with eight triangular and 18 square facets.
    - "truncated_cuboctahedron" : Truncated Cuboctahedron.
          Regular polytope with 12 square, eight hexagonal and six octagonal
          facets.
    - "snub_cube" : Snub Cube.
          Regular polytope with 32 triangular and six square facets.
          The vertices are realized as floating point numbers.
          This is a chiral polytope.
    - "icosidodecahedron" : Icosidodecahedon.
          Regular polytope with 20 triangular and 12 pentagonal facets.
    - "truncated_dodecahedron" : Truncated Dodecahedron.
          Regular polytope with 20 triangular and 12 decagonal facets.
    - "truncated_icosahedron" : Truncated Icosahedron.
          Regular polytope with 12 pentagonal and 20 hexagonal facets.
    - "rhombicosidodecahedron" : Rhombicosidodecahedron.
          Regular polytope with 20 triangular, 30 square and 12 pentagonal
          facets.
    - "truncated_icosidodecahedron" : Truncated Icosidodecahedron.
          Regular polytope with 30 square, 20 hexagonal and 12 decagonal
          facets.
    - "snub_dodecahedron" : Snub Dodecahedron.
          Regular polytope with 80 triangular and 12 pentagonal facets.
          The vertices are realized as floating point numbers.
          This is a chiral polytope.

# Examples
```jldoctest
julia> T = archimedean_solid("cuboctahedron")
Polyhedron in ambient dimension 3

julia> sum([nvertices(F) for F in faces(T, 2)] .== 3)
8

julia> sum([nvertices(F) for F in faces(T, 2)] .== 4)
6

julia> nfacets(T)
14
```
"""
archimedean_solid(s::String) = polyhedron(Polymake.polytope.archimedean_solid(s))

@doc raw"""
    catalan_solid(s::String)

Construct a Catalan solid with the name `s` from the list
below.  The polytopes are realized with floating point coordinates and thus are not
exact. However, vertex-facet-incidences are correct in all cases.

# Arguments
- `s::String`: The name of the desired Archimedean solid.
    Possible values:
    - "triakis_tetrahedron" : Triakis Tetrahedron.
          Dual polytope to the Truncated Tetrahedron, made of 12 isosceles
          triangular facets.
    - "triakis_octahedron" : Triakis Octahedron.
          Dual polytope to the Truncated Cube, made of 24 isosceles triangular
          facets.
    - "rhombic_dodecahedron" : Rhombic dodecahedron.
          Dual polytope to the cuboctahedron, made of 12 rhombic facets.
    - "tetrakis_hexahedron" : Tetrakis hexahedron.
          Dual polytope to the truncated octahedron, made of 24 isosceles
          triangluar facets.
    - "disdyakis_dodecahedron" : Disdyakis dodecahedron.
          Dual polytope to the truncated cuboctahedron, made of 48 scalene
          triangular facets.
    - "pentagonal_icositetrahedron" : Pentagonal Icositetrahedron.
          Dual polytope to the snub cube, made of 24 irregular pentagonal facets.
          The vertices are realized as floating point numbers.
    - "pentagonal_hexecontahedron" : Pentagonal Hexecontahedron.
          Dual polytope to the snub dodecahedron, made of 60 irregular pentagonal
          facets. The vertices are realized as floating point numbers.
    - "rhombic_triacontahedron" : Rhombic triacontahedron.
          Dual polytope to the icosidodecahedron, made of 30 rhombic facets.
    - "triakis_icosahedron" : Triakis icosahedron.
          Dual polytope to the icosidodecahedron, made of 30 rhombic facets.
    - "deltoidal_icositetrahedron" : Deltoidal Icositetrahedron.
          Dual polytope to the rhombicubaoctahedron, made of 24 kite facets.
    - "pentakis_dodecahedron" : Pentakis dodecahedron.
          Dual polytope to the truncated icosahedron, made of 60 isosceles
          triangular facets.
    - "deltoidal_hexecontahedron" : Deltoidal hexecontahedron.
          Dual polytope to the rhombicosidodecahedron, made of 60 kite facets.
    - "disdyakis_triacontahedron" : Disdyakis triacontahedron.
          Dual polytope to the truncated icosidodecahedron, made of 120 scalene
          triangular facets.


# Examples
```jldoctest
julia> T = catalan_solid("triakis_tetrahedron");

julia> count(F -> nvertices(F) == 3, faces(T, 2))
12

julia> nfacets(T)
12
```
"""
catalan_solid(s::String) = polyhedron(Polymake.polytope.catalan_solid(s))


@doc raw"""
    upper_bound_f_vector(d::Int, n::Int)

Return the maximal f-vector of a `d`-polytope with `n` vertices;
this is given by McMullen's Upper-Bound-Theorem.
"""
upper_bound_f_vector(d::Int,n::Int) = Vector{Int}(Polymake.polytope.upper_bound_theorem(d,n).F_VECTOR)

@doc raw"""
    upper_bound_g_vector(d::Int, n::Int)

Return the maximal g-vector of a `d`-polytope with `n` vertices;
this is given by McMullen's Upper-Bound-Theorem.
"""
upper_bound_g_vector(d::Int,n::Int) = Vector{Int}(Polymake.polytope.upper_bound_theorem(d,n).G_VECTOR)

@doc raw"""
    upper_bound_h_vector(d::Int, n::Int)

Return the maximal h-vector of a `d`-polytope with `n` vertices;
this is given by McMullen's Upper-Bound-Theorem.
"""
upper_bound_h_vector(d::Int,n::Int) = Vector{Int}(Polymake.polytope.upper_bound_theorem(d,n).H_VECTOR)

@doc raw"""
    billera_lee_polytope(h::AbstractVector)

Construct a simplicial polytope whose h-vector is $h$.
The corresponding g-vector must be an M-sequence.
The ambient dimension equals the length of $h$, and the polytope lives in codimension one.
- [BL81](@cite)

# Examples
```jldoctest
julia> BL = billera_lee_polytope([1,3,3,1])
Polyhedron in ambient dimension 4

julia> f_vector(BL)
3-element Vector{ZZRingElem}:
 6
 12
 8

```
"""
billera_lee_polytope(h::AbstractVector) = Polyhedron{QQFieldElem}(Polymake.polytope.billera_lee(Polymake.Vector{Polymake.Integer}(h)))

@doc raw"""
    polarize(P::Polyhedron)

Return the polar dual of the polyhedron `P`, consisting of all linear functions
whose evaluation on `P` does not exceed 1.

# Examples
```jldoctest
julia> square = cube(2)
Polyhedron in ambient dimension 2

julia> P = polarize(square)
Polyhedron in ambient dimension 2

julia> vertices(P)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [1, 0]
 [-1, 0]
 [0, 1]
 [0, -1]
```
"""
function polarize(P::Polyhedron{T}) where T<:scalar_types
    return Polyhedron{T}(Polymake.polytope.polarize(pm_object(P)))
end


@doc raw"""
    project_full(P::Polyhedron)

Project the polyhedron down such that it becomes full dimensional in the new
ambient space.

# Examples
```jldoctest
julia> P = convex_hull([1 0 0; 0 0 0])
Polyhedron in ambient dimension 3

julia> is_fulldimensional(P)
false

julia> p = project_full(P)
Polyhedron in ambient dimension 1

julia> is_fulldimensional(p)
true
```
"""
project_full(P::Polyhedron{T}) where T<:scalar_types = Polyhedron{T}(Polymake.polytope.project_full(pm_object(P)))

@doc raw"""
    gelfand_tsetlin_polytope(lambda::AbstractVector)

Construct the Gelfand Tsetlin polytope indexed by a weakly decreasing vector `lambda`.

# Examples
```jldoctest
julia> P = gelfand_tsetlin_polytope([5,3,2])
Polyhedron in ambient dimension 6

julia> is_fulldimensional(P)
false

julia> p = project_full(P)
Polyhedron in ambient dimension 3

julia> is_fulldimensional(p)
true

julia> volume(p)
3
```
"""
gelfand_tsetlin_polytope(lambda::AbstractVector) = Polyhedron{QQFieldElem}(Polymake.polytope.gelfand_tsetlin(Polymake.Vector{Polymake.Rational}(lambda), projected = false))

@doc raw"""
    fano_simplex(d::Int)

Construct a lattice simplex such that the origin is the unique interior lattice point.
The normal toric variety associated with its face fan is smooth.

# Keywords
- `d::Int`: the dimension.

Note that in polymake, this function has an optional Boolean parameter `group`, to
also construct the symmetry group of the simplex.  

# Examples
```jldoctest
julia> S = fano_simplex(3)
Polyhedron in ambient dimension 3

julia> X = normal_toric_variety(face_fan(S))
Normal toric variety

julia> is_smooth(X)
true
```
"""
fano_simplex(d::Int) = Polyhedron{QQFieldElem}(Polymake.polytope.fano_simplex(d))

@doc raw"""
    del_pezzo_polytope(d::Int)

Produce the d-dimensional del Pezzo polytope, which is the convex hull of
the cross polytope together with the all-ones and minus all-ones vector.

# Examples
```jldoctest
julia> DP = del_pezzo_polytope(4)
Polyhedron in ambient dimension 4

julia> f_vector(DP)
4-element Vector{ZZRingElem}:
 10
 40
 60
 30
```
"""
del_pezzo_polytope(d::Int) = Polyhedron{QQFieldElem}(Polymake.polytope.delpezzo(d))

@doc raw"""
    cyclic_polytope(d::Int, n::Int)

Construct the cyclic polytope that is the convex hull of $n$ points on the
moment curve in dimension $d$.

# Examples
```jldoctest
julia> cp = cyclic_polytope(3, 20)
Polyhedron in ambient dimension 3

julia> nvertices(cp)
20
```
"""
cyclic_polytope(d::Int, n::Int) = polyhedron(Polymake.polytope.cyclic(d, n))

# random constructions

@doc raw"""
    rand_spherical_polytope([rng::AbstractRNG,] d::Int, n::Int;
    distribution=:uniform, precision=nothing, seed=nothing)

Construct the convex hull of $n$ points on the unit sphere in $\mathbb{R}^d$.
Almost surely this is a simplicial polytope.

# Keywords
- `distribution::Symbol`: One of the following two options:
  - `:uniform` (default): Use intermediate floating point numbers for an almost
                          uniform distribution on the sphere.
                          The points will not be exactly on the sphere.
  - `:exact`:             Create exact rational points on the unit sphere, this
                          works at the expense of both uniformity and log-height
                          of the points.
- `precision::Int64`:     Precision in bits during floating point approximation
                          for uniform distribution.
- `seed::Int64`:          Seed for random number generation. Cannot be used
                          together with the `AbstractRNG` argument.

# Examples
```jldoctest
julia> rsph = rand_spherical_polytope(3, 20)
Polyhedron in ambient dimension 3

julia> is_simplicial(rsph)
true

julia> rsph = rand_spherical_polytope(3, 4; precision=5, seed=132)
Polyhedron in ambient dimension 3

julia> map(x->dot(x,x), vertices(rsph))
4-element Vector{QQFieldElem}:
 4306545//4194304
 15849//16384
 4165//4096
 8281//8192

julia> rsph = rand_spherical_polytope(3, 4; distribution=:exact)
Polyhedron in ambient dimension 3

julia> map(x->dot(x,x), vertices(rsph))
4-element Vector{QQFieldElem}:
 1
 1
 1
 1

```
"""
function rand_spherical_polytope(d::Int, n::Int; distribution::Symbol=:uniform, seed=nothing, precision=nothing)
  if distribution === :uniform
    type = "AccurateFloat"
  elseif distribution === :exact
    type = "Rational"
  else
    throw(ArgumentError("rand_spherical_polytope: invalid distribution specified"))
  end
  opts = Dict{Symbol,Any}( :template_parameters => [type] ) # creating the Optionset, the :template_parameters are for templating functions in C++
  if seed != nothing
    opts[:seed] = convert(Int64, seed)
  end
  if precision != nothing
    opts[:precision] = convert(Int64, precision)
  end
  pm_obj = Polymake.call_function(:polytope, :rand_sphere, d, n; opts...)::Polymake.BigObject # specifying the Type so it will throw an error if its not this type
  return Polyhedron{QQFieldElem}(pm_obj)
end

rand_spherical_polytope(rng::AbstractRNG, d::Int, n::Int; distribution::Symbol=:uniform, precision=nothing) =
  rand_spherical_polytope(d, n; distribution=distribution, seed=rand(rng,Int64), precision=precision)

@doc raw"""
    rand_subpolytope(P::Polyhedron, n::Int; seed=nothing)

Construct a subpolytope of $P$ as the convex hull of $n$ vertices, chosen uniformly at random.
The polyhedron $P$ must be bounded, and the number $n$ must not exceed the number of vertices.

# Keywords
- `seed::Int64`:          Seed for random number generation.

# Examples
```jldoctest
julia> nvertices(rand_subpolytope(cube(3), 5))
5

```
"""
function rand_subpolytope(P::Polyhedron{T}, n::Int; seed=nothing) where T<:scalar_types
  if !bounded(P)
    throw(ArgumentError("rand_subpolytope: Polyhedron unbounded"))
  end
  nv = nvertices(P)
  if n>nv
    throw(ArgumentError("rand_subpolytope: number of vertices requested too high"))
  end
  opts = Dict{Symbol,Any}()
  if seed != nothing
    opts[:seed] = convert(Int64, seed)
  end
  pm_matrix = Polymake.polytope.rand_vert(P.pm_polytope.VERTICES, n; opts...)
  pm_obj = Polymake.polytope.Polytope(VERTICES=pm_matrix)::Polymake.BigObject
  return Polyhedron{T}(pm_obj)
end

@doc raw"""
    SIM_body(alpha::AbstractVector)

Produce an $n$-dimensional SIM-body as generalized permutahedron in 
$(n+1)$-space. SIM-bodies are defined in [GK14](@cite), but the input needs to 
be descending instead of ascending, as used in [JKS22](@cite).

# Keywords
- `alpha::AbstractVector`: Vector with the parameters 
$(a_1,\dots,a_n)$ such that $a_1 \geq \dots \geq a_n \geq 0$. 

# Examples
To produce a $2$-dimensional SIM-body, use for example the following code. 
Note that the polytope lives in $3$-space, so we project it down to $2$-space 
by eliminating the last coordinate. 

```jldoctest
julia> p = SIM_body([3,1])
Polyhedron in ambient dimension 3

julia> s = convex_hull(map(x->x[1:dim(p)],vertices(p)))
Polyhedron in ambient dimension 2
```
"""
function SIM_body(alpha::Vector) 
    n = length(alpha)
    if n < 1
        throw(ArgumentError("SIM-body: dimension must be at least 1"))
    end
    for i in 1:n-1
        if alpha[i]<alpha[i+1]
            throw(ArgumentError("SIM-body: input is not descending"))
        end
    end
    return Polyhedron{QQFieldElem}(Polymake.polytope.sim_body(Polymake.Vector{Polymake.Rational}(alpha)))
end


@doc raw"""
    associahedron(d::Int)

Produce a $d$-dimensional associahedron (or Stasheff polytope). 
We use the facet description given in section 9.2. of [Zie95](@cite).

# Keywords
- `d::Int`: the dimension 

Note that in polymake, this function has an optional Boolean parameter `group`, to
also construct the symmetry group of the polytope. For details, see [CSZ15](@cite).


# Examples
The $2$-dimensional associahedron is a polygon in $\mathbb{R}⁴$ having $5$ vertices
and $5$ facets.
```jldoctest
julia> A =  associahedron(2)
Polyhedron in ambient dimension 4

julia> vertices(A)
5-element SubObjectIterator{PointVector{QQFieldElem}}:
 [9, 4, 1, 10]
 [10, 1, 4, 9]
 [1, 10, 1, 9]
 [1, 4, 9, 6]
 [4, 1, 10, 6]

julia> facets(A)
5-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the Halfspaces of R^4 described by:
-x₁ ≦ -1
-2*x₁ - 2*x₂ ≦ -10
-x₂ ≦ -1
-2*x₂ - 2*x₃ ≦ -10
-x₃ ≦ -1
```
"""
associahedron(d::Int) = Polyhedron{QQFieldElem}(Polymake.polytope.associahedron(d)) 


@doc raw""" 
    binary_markov_graph(observation::Array{Bool})

Defines a very simple graph for a polytope propagation related to a Hidden 
Markov Model. The propagated polytope is always a polygon. For a detailed 
description see [Jos05](@cite).

# Examples
```jldoctest
julia> P = binary_markov_graph([1,1,1,1])
Polyhedron in ambient dimension 2

julia> vertices(P)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [3, 0]
 [1, 1]
 [0, 2]
 [0, 7]
```
"""
binary_markov_graph(observation::Vector{Bool}) = Polyhedron{QQFieldElem}(Polymake.polytope.binary_markov_graph(Vector{Int}(observation)))

@doc raw"""
    dwarfed_cube(d::Int)

Produce a $d$-dimensional dwarfed cube as defined in [ABS97](@cite). 

# Keywords
- `d::Int`: the dimension 

# Examples
The $3$-dimensional dwarfed cube is illustrated in [Jos03](@cite).

```jldoctest
julia> c = dwarfed_cube(3)
Polyhedron in ambient dimension 3

julia> vertices(c)
10-element SubObjectIterator{PointVector{QQFieldElem}}:
 [1//2, 0, 1]
 [1//2, 1, 0]
 [1, 0, 1//2]
 [1, 1//2, 0]
 [1, 0, 0]
 [0, 0, 0]
 [0, 1, 0]
 [0, 1//2, 1]
 [0, 0, 1]
 [0, 1, 1//2]
```
"""
function dwarfed_cube(d::Int)
    if d<2
        throw(ArgumentError("dwarfed_cube: d >= 2 required"))
    end
    return Polyhedron{QQFieldElem}(Polymake.polytope.dwarfed_cube(d))
end


@doc raw"""
    dwarfed_product_polygons(d::Int, s::Int)

Produce a $d$-dimensional dwarfed product of polygons of size $s$ as defined in [ABS97](@cite). 

# Keywords
- `d::Int`: the dimension. It must be $d\geq4$ and even. 
- `s::Int`: the size. It must be $s\geq 3$

# Examples
```jldoctest
julia> p = dwarfed_product_polygons(4,3)
Polyhedron in ambient dimension 4

julia> vertices(p)
11-element SubObjectIterator{PointVector{QQFieldElem}}:
 [5, 3, 0, 0]
 [5, 0, 0, 0]
 [2, 0, 3, 9]
 [0, 0, 5, 3]
 [0, 0, 3, 9]
 [2, 6, 3, 9]
 [0, 0, 5, 0]
 [0, 0, 0, 0]
 [3, 9, 2, 6]
 [3, 9, 2, 0]
 [3, 9, 0, 0]
```
"""
function dwarfed_product_polygons(d::Int, s::Int) 
    if d <= 2 || d%2 != 0
        throw(ArgumentError("dwarfed_product_polygons: d >= 4 and even required"))
    end
    if s<=2
        throw(ArgumentError("dwarfed_product_polygons: s >= 3 required"))
    end
    return Polyhedron{QQFieldElem}(Polymake.polytope.dwarfed_product_polygons(d,s))
end

@doc raw"""
    lecture_hall_simplex(d::Int)

Produce the $d$-dimensional lecture hall simplex for the sequence $(s_i)=i$ for $1\geq i \geq d$
as defined in [SS12](@cite).

# Keywords
- `d::Int`: the dimension 

Note that in polymake, this function has an optional Boolean parameter `group`, to
also construct the symmetry group of the simplex.  

# Examples
A $3$-dimensional lecture hall simplex:
```jldoctest
julia> S = lecture_hall_simplex(3) 
Polyhedron in ambient dimension 3

julia> vertices(S)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [0, 0, 0]
 [0, 0, 3]
 [0, 2, 3]
 [1, 2, 3]
```
"""
function lecture_hall_simplex(d::Int) 
    if d<=0
        throw(ArgumentError("lecture_hall_simplex: dimension must be positive."))
    end
    return Polyhedron{QQFieldElem}(Polymake.polytope.lecture_hall_simplex(d))
end

@doc raw"""
    explicit_zonotope(zones::Matrix)

Produce the points of a zonotope as the iterated Minkowski sum of all intervals $[-x,x]$, 
where $x$ ranges over the rows of the input matrix `zones`. 

# Keywords
- `zones::Matrix`: the input vectors 
- `rows_are_points::Bool`: the rows of the input matrix represent affine points(`true`, default) or linear vectors(`false`). 

# Examples
```jldoctest
julia> Z = explicit_zonotope([1 1; 1 -1], false)
Polyhedron in ambient dimension 2

julia> vertices(Z)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [2, 0]
 [0, -2]
 [0, 2]
 [-2, 0]
```
"""
explicit_zonotope(zones::Matrix{<:Number}, rows_are_points::Bool=true)  = Polyhedron(Polymake.polytope.explicit_zonotope(Matrix{Polymake.Rational}(zones), rows_are_points=rows_are_points)) 

@doc raw"""
    cyclic_caratheodory(d::Int, n::Int)

Produce a $d$-dimensional cyclic polytope with $n$ points. Prototypical example of a neighborly polytope. 
Combinatorics completely known due to Gale's evenness criterion. Coordinates are chosen on the 
trigonometric moment curve.

# Keywords
- `d::Int`: the dimension has to be even.
- `n::Int`: the number of points `n` has to be be $\geq d$ 

# Examples
```jldoctest
julia> C= cyclic_caratheodory(4,5)
Polyhedron in ambient dimension 4

julia> vertices(C)
5-element SubObjectIterator{PointVector{QQFieldElem}}:
 [1, 0, 1, 0]
 [347922205179541//1125899906842624, 8566355544790271//9007199254740992, -7286977268806823//9007199254740992, 5294298886396511//9007199254740992]
 [-7286977268806823//9007199254740992, 5294298886396511//9007199254740992, 1391688820718163//4503599627370496, -33462326346837//35184372088832]
 [-7286977268806825//9007199254740992, -5294298886396509//9007199254740992, 5566755282872661//18014398509481984, 8566355544790271//9007199254740992]
 [1391688820718163//4503599627370496, -33462326346837//35184372088832, -3643488634403413//4503599627370496, -5294298886396507//9007199254740992]
```
"""
function cyclic_caratheodory(d::Int, n::Int)
    if n < d 
        throw(ArgumentError("Dimension d has to be smaller than number of points n."))
    end
    if d < 2
        throw(ArgumentError("Dimension has to be greater or equal to 2."))
    end
    if mod(d,2) != 0
        throw(ArgumentError("Dimension has to be even."))
    end
    return Polyhedron(Polymake.polytope.cyclic_caratheodory(d,n))
end

@doc raw"""
    fractional_knapsack(b::Vector)

Produce a knapsack polytope defined by one linear inequality (and non-negativity constraints).

# Keywords
- `b::Vector`: Entries in vector have to be rational, represents a linear inequality

# Example 
```jldoctest
julia> p= fractional_knapsack([1;2;3;4])
Polyhedron in ambient dimension 3

julia> print_constraints(p)
-x₁ ≦ 0
-x₂ ≦ 0
-x₃ ≦ 0
```
"""
fractional_knapsack(b::Vector{Rational}) = Polyhedron{QQFieldElem}(Polymake.polytope.fractional_knapsack(b))
fractional_knapsack(b::Vector{Int}) = fractional_knapsack(convert(Vector{Rational}, b))

@doc raw"""
    hypersimplex(k::Int, d::Int)

Produce the hypersimplex $\Delta(k,d)$, that is the the convex hull of all $0/1$-vector in $\mathbb{R}^d$ with exactly $k$ ones. Note that the output is never full-dimensional.

# Keywords
- `k::Int`: number of ones
- `d::Int`: ambient dimension
- `no_vertices::Bool`: This is an optional parameter, if set equal to `true`, vertices are not computed.
- `no_facets::Bool`: This is an optional parameter, if set equal to `true`, facets are not computed.
- `no_vif::Bool`: This is an optional parameter, if set equal to `true``, vertices and facets are not computed.

# Example
```jldoctest
julia> H = hypersimplex(3,4)
Polyhedron in ambient dimension 4

julia> G = hypersimplex(3,4,no_facets=true)
Polyhedron in ambient dimension 4

julia> facets(G)
4-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the Halfspaces of R^4 described by:
x₄ ≦ 1
x₃ ≦ 1
-x₁ - x₃ - x₄ ≦ -2
x₁ ≦ 1

julia> facets(H)
4-element SubObjectIterator{AffineHalfspace{QQFieldElem}} over the Halfspaces of R^4 described by:
x₄ ≦ 1
x₃ ≦ 1
-x₁ - x₃ - x₄ ≦ -2
x₁ ≦ 1
```
"""
function hypersimplex(k::Int, d::Int; no_vertices::Bool=false, no_facets::Bool=false, no_vif::Bool=false) 
    opts = Dict{Symbol, Bool}(:no_vertices=>no_vertices, :no_facets=>no_facets, :no_vif=>no_vif)
    return Polyhedron{QQFieldElem}(Polymake.polytope.hypersimplex(k,d;opts...))
end

@doc raw"""
    zonotope(M::Matrix)

Create a zonotope from a matrix whose rows are input points or vectors.

# Keywords
- `M::Matrix`: input points or vectors.
- `rows_are_points::Bool`: This optional parameter is `true` in case `M` consists of points instead of vectors; the default is `true`.
- `centered::Bool`: This optional parameter  is `true` if the output should be centered; the default is `true`.

# Examples
The following produces a parallelogram with the origin as its vertex barycenter: 
```jldoctest
julia> Z = zonotope([1 1 0; 1 1 1])
Polyhedron in ambient dimension 2

julia> vertices(Z)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [-1, -1//2]
 [0, -1//2]
 [0, 1//2]
 [1, 1//2]
```
The following produces a parallelogram with the origin being a vertex (not centered case): 
```jldoctest
julia> Z = zonotope([1 1 0; 1 1 1], true, false)
Polyhedron in ambient dimension 2

julia> vertices(Z)
4-element SubObjectIterator{PointVector{QQFieldElem}}:
 [0, 0]
 [1, 0]
 [1, 1]
 [2, 1]
```
"""
zonotope(M::Matrix{<:Number}, rows_are_points::Bool=true, centered::Bool=true)  = Polyhedron(Polymake.polytope.zonotope(Matrix{Polymake.Rational}(M), rows_are_points=rows_are_points, centered=centered)) 

@doc raw"""
    goldfarb_cube(d::Int, e::Real, g::Real)

# Keywords
- `d::Int`: the dimension
- `e::Real`: first parameter of deformation, it must be $<\frac{1}{2}$. 
- `g::Real`: second parameter of deformation, it must be $\geq \frac{e}{4}$. 
    
The Goldfarb cube is a combinatorial cube and yields a bad example for the 
Simplex Algorithm using the Shadow Vertex Pivoting Strategy. 
Here we use the description as a deformed product due to [AZ99](@cite). 
For $e<\frac{1}{2}$ and $g=0$ we obtain the Klee-Minty cubes, 
in particular for $e=g=0$ we obtain the standard cube. 

# Examples
The following produces a $3$-dimensional Klee-Minty cube for $e=\frac{1}{3}.
```jldoctest
julia> c=goldfarb_cube(3,1//3,0)
Polyhedron in ambient dimension 3

julia> vertices(c)
8-element SubObjectIterator{PointVector{QQFieldElem}}:
 [1, 1//3, 8//9]
 [1, 2//3, 7//9]
 [1, 2//3, 2//9]
 [1, 1//3, 1//9]
 [0, 0, 0]
 [0, 1, 1//3]
 [0, 1, 2//3]
 [0, 0, 1]
```
"""
function goldfarb_cube(d::Int, e::Real, g::Real)
    m = 8*sizeof(Int)-2
    if d<1 || d>m
        throw(ArgumentError("goldfarb: dimension ot of range (1,..," * string(m) * ")"))
    end
    if e>=1//2
        throw(ArgumentError("goldfarb: e < 1/2"))
    end
    if g>e/4
        throw(ArgumentError("goldfarb: g <= e/4"))
    end
    return Polyhedron(Polymake.polytope.goldfarb(d,e,g))
end

@doc raw"""
    goldfarb_sit_cube(d::Int, e::Real, g::Real)

Produces a d-dimensional variation of the Klee-Minty cube, which is scaled in direction $x_{d-i}$ 
by `eps*delta^i`. 
This cube is a combinatorial cube and yields a bad example for the Simplex Algorithm using the 
Steepest Edge Pivoting Strategy. Here we use a scaled description of the construction of Goldfarb and Sit, 
see [GS79](@cite).

# Keywords
- `d::Int`: the dimension
- `eps::Real`: must be $<\frac{1}{2}$.
- `delta::Real`: must be $\geq\frac{1}{2}$.
    

# Examples
```jldoctest
julia> c=goldfarb_sit_cube(3,1//3,1//2)
Polyhedron in ambient dimension 3

julia> vertices(c) 
8-element SubObjectIterator{PointVector{QQFieldElem}}:
 [1//36, 1//18, 8//9]
 [1//36, 1//9, 7//9]
 [1//36, 1//9, 2//9]
 [1//36, 1//18, 1//9]
 [0, 0, 0]
 [0, 1//6, 1//3]
 [0, 1//6, 2//3]
 [0, 0, 1]
```
"""
function goldfarb_sit_cube(d::Int, eps::Real, delta::Real) 
    m = 8*sizeof(Int)-2
    if d<1 || d>m
        throw(ArgumentError("goldfarb_sit: dimension ot of range (1,..," * string(m) * ")"))
    end
    if eps>=1//2
        throw(ArgumentError("goldfarb_sit: eps < 1/2"))
    end
    if delta>1//2
        throw(ArgumentError("goldfarb_sit: delta <= 1/2"))
    end
    return Polyhedron(Polymake.polytope.goldfarb_sit(d,eps,delta))
end

@doc raw"""

Produce a $d-$dimensional hypertruncated cube. With symmetric linear objective function $(0,1,1,…,1)$.

# Keywords
- `d::Int`: the dimension
- `k::Number`: cutoff parameter
- `lambda::Number`: scaling of extra vertex

# Example
```jldoctest
julia> H = hypertruncated_cube(3,2,3)
Polyhedron in ambient dimension 3

julia> print_constraints(H)
-x₁ ≦ 0
-x₂ ≦ 0
-x₃ ≦ 0
x₁ ≦ 1
x₂ ≦ 1
x₃ ≦ 1
5*x₁ - 2*x₂ - 2*x₃ ≦ 3
-2*x₁ + 5*x₂ - 2*x₃ ≦ 3
-2*x₁ - 2*x₂ + 5*x₃ ≦ 3
```
"""
function hypertruncated_cube(d::Int, k::Number, lambda::Number) 
    if 1 >= k || k >= d
        throw(ArgumentError("1 < k < d required"))
    end
    return Polyhedron{QQFieldElem}(Polymake.polytope.hypertruncated_cube(d, k, lambda))
end

@doc raw"""
   k_cylic(n::Int, s::Vector) 

Produce a (rounded) $2*k$-dimensional $k$-cyclic polytope with $n$ points, where $k$ is the length of the input vector $s$. Special cases are the bicyclic ($k=2$) and tricyclic ($k=3$) polytopes. Only possible in even dimensions. The parameters $s_i$ can be specified as integer, floating-point, or rational numbers. The coordinates of the $i$-th point are taken as follows:
$(\cos(s_1 * 2\pi i/n), \sin(s_1 * 2\pi i/n), ... , \cos(s_k * 2\pi i/n), sin(s_k * 2\pi i/n)).

Warning: Some of the $k-$cyclic polytopes are not simplicial. Since the components are rounded, this function might output a polytope which is not a $k-$cyclic polytope! More information see [Sch95](@cite).

# Keywords
- `n::Int`: number of points
- `s::Vector`: input Vector

# Example
To produce a (not exactly) regular pentagon, type this:
```jldoctest
julia> k_cyclic(5,[1])
Polyhedron in ambient dimension 2
```
"""
k_cyclic(n::Int, s::Vector) = Polyhedron{QQFieldElem}(Polymake.polytope.k_cyclic(n,s))

@doc raw"""
    klee_minty_cube(d::Int, e::Number)

Produces a $d-$dimensional Klee-Minty-cube if $e < 1/2$. Uses the `goldfarb` method with the argument $g = 0$.

# Example
For an example see `goldfarb` method.
```
"""
klee_minty_cube(d::Int, e::Number) = goldfarb_cube(d, e, 0)
