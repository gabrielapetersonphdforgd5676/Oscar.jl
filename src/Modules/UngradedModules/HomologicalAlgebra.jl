####################
### Chain Complexes
####################

@doc raw"""
    chain_complex(V::ModuleFPHom...; seed::Int = 0)

Given a tuple `V` of module homorphisms between successive modules over a multivariate polynomial ring, 
return the chain complex defined by these homomorphisms.

    chain_complex(V::Vector{<:ModuleFPHom}; seed::Int = 0)

Given a vector `V` of module homorphisms between successive modules over a multivariate polynomial ring, 
return the chain complex defined by these homomorphisms.

!!! note
    The integer `seed` indicates the lowest homological degree of a module in the complex.

!!! note
    The function checks whether successive homomorphisms indeed compose to zero.
"""
function chain_complex(V::ModuleFPHom...; seed::Int = 0)
  return ComplexOfMorphisms(ModuleFP, collect(V); typ = :chain, seed = seed)
end

function chain_complex(V::Vector{<:ModuleFPHom}; seed::Int = 0, check::Bool=true)
  return ComplexOfMorphisms(ModuleFP, V; typ = :chain, seed = seed, check=check)
end

####################

####################
### Cochain Complexes
####################

@doc raw"""
    cochain_complex(V::ModuleFPHom...; seed::Int = 0)

Given a tuple `V` of module homorphisms between successive modules over a multivariate polynomial ring, 
return the cochain complex defined by these homomorphisms.

    cochain_complex(V::Vector{<:ModuleFPHom}; seed::Int = 0)

Given a vector `V` of module homorphisms between successive modules over a multivariate polynomial ring, 
return the cochain complex defined by these homomorphisms.

!!! note
    The integer `seed` indicates the lowest cohomological degree of a module of the complex.

!!! note
    The function checks whether successive homomorphisms indeed compose to zero.
"""
function cochain_complex(V::ModuleFPHom...; seed::Int = 0)
  return ComplexOfMorphisms(ModuleFP, collect(V); typ = :cochain, seed = seed)
end

function cochain_complex(V::Vector{<:ModuleFPHom}; seed::Int = 0)
  return ComplexOfMorphisms(ModuleFP, V; typ = :cochain, seed = seed)
end

####################

@doc raw"""
    presentation(M::SubquoModule)

Return a free presentation of `M`. 
"""
function presentation(SQ::SubquoModule)
  #A+B/B is generated by A and B
  #the relations are A meet B? written wrt to A
  R = base_ring(SQ)
  if is_graded(SQ)
    h_F_SQ = graded_map(SQ, gens(SQ))
    F = domain(h_F_SQ)
  else
    F = FreeMod(R, ngens(SQ.sub))
    h_F_SQ = hom(F, SQ, gens(SQ)) # DO NOT CHANGE THIS LINE, see present_as_cokernel and preimage
  end
  br_name = AbstractAlgebra.find_name(R)
  if br_name === nothing
    br_name = "br"
  end
  set_attribute!(F,  :name => "$br_name^$(ngens(SQ.sub))")
  q = elem_type(F)[]
  if is_generated_by_standard_unit_vectors(SQ.sub)
    if isdefined(SQ, :quo)
      q = [FreeModElem(coordinates(g), F) for g in gens(SQ.quo)]
    end
  else
    if is_graded(SQ)
      s, _ = kernel(graded_map(ambient_free_module(SQ), gens(SQ.sum)))
    else
      s, _ = kernel(hom(FreeMod(R,ngens(SQ.sum)), ambient_free_module(SQ), gens(SQ.sum)))
    end
    #s = syzygy_module(SQ.sum.gens)
    #TODO: wait for Hans to release Modulo(A, B) that does exactly this
    c = collect(s.sub.gens)
    #q = elem_type(F)[]

    for x = c
      b = sparse_row(R)
      e = zero(SQ.F)
      for (i,v) = x.coords
        if i>ngens(SQ)
          break
        end
        e += v*gen(SQ, i).repres
        push!(b.pos, i)
        push!(b.values, v)
      end
      if length(b) == 0
        continue
      end
      push!(q, FreeModElem(b, F))
    end
  end
  #want R^a -> R^b -> SQ -> 0
  #from Hans:
  # as a complex R^b has index 0
  #              R^a           1
  # so 0 has index -2, hence seed has to be -2
  #TODO sort decoration and fix maps, same decoration should be bundled (to match pretty printing)
  if is_graded(SQ)
    h_G_F = graded_map(F, q)
    G = domain(h_G_F)
  else
    G = FreeMod(R, length(q))
    h_G_F = hom(G, F, q)
  end
  br_name = AbstractAlgebra.find_name(F.R)
  if br_name === nothing
    br_name = "br"
  end
  set_attribute!(G, :name => "$br_name^$(length(q))")
  if is_graded(SQ)
    Z = graded_free_module(F.R, 0)
  else
    Z = FreeMod(F.R, 0)
  end
  set_attribute!(Z, :name => "0")
  h_SQ_Z = hom(SQ, Z, Vector{elem_type(Z)}([zero(Z) for i=1:ngens(SQ)]))
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[h_G_F, h_F_SQ, h_SQ_Z], check = false, seed = -2)
  set_attribute!(M, :show => Hecke.pres_show)
  return M
end

@doc raw"""
    presentation(F::FreeMod)

Return a free presentation of `F`.
"""
function presentation(F::FreeMod)
  if is_graded(F)
    Z = graded_free_module(F.R, 0)
  else
    Z = FreeMod(F.R, 0)
  end
  set_attribute!(Z, :name => "0")
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[hom(Z, F, Vector{elem_type(F)}()), hom(F, F, gens(F)), hom(F, Z, Vector{elem_type(Z)}([zero(Z) for i=1:ngens(F)]))], check = false, seed = -2)
  set_attribute!(M, :show => Hecke.pres_show)
  return M
end

@doc raw"""
    presentation(M::ModuleFP)

Return a free presentation of `M`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> A = R[x; y];

julia> B = R[x^2; y^3; z^4];

julia> M = SubquoModule(A, B);

julia> P = presentation(M)
0 <---- M <---- R^2 <---- R^5
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, [1,2,2]);

julia> p = presentation(F)
0 <---- F <---- F <---- 0

julia> p[-2]
Graded free module Rg^0 of rank 0 over Rg

julia> p[-1]
Graded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg

julia> p[0]
Graded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg

julia> p[1]
Graded free module Rg^0 of rank 0 over Rg

julia> map(p,-1)
F -> 0
e[1] -> 0
e[2] -> 0
e[3] -> 0
Homogeneous module homomorphism

julia> map(p,0)
F -> F
e[1] -> e[1]
e[2] -> e[2]
e[3] -> e[3]
Homogeneous module homomorphism

julia> map(p,1)
0 -> F
Homogeneous module homomorphism

julia> F = graded_free_module(Rg, 1);

julia> A = Rg[x; y];

julia> B = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, A, B);

julia> P = presentation(M)
0 <---- M <---- Rg^2 <---- Rg^5

julia> P[-2]
Graded free module Rg^0 of rank 0 over Rg

julia> P[-1]
Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> P[0]
Graded free module Rg^2([-1]) of rank 2 over Rg

julia> P[1]
Graded free module Rg^2([-2]) + Rg^1([-3]) + Rg^2([-5]) of rank 5 over Rg

julia> map(P,-1)
M -> 0
x*e[1] -> 0
y*e[1] -> 0
Homogeneous module homomorphism

julia> map(P,0)
Rg^2 -> M
e[1] -> x*e[1]
e[2] -> y*e[1]
Homogeneous module homomorphism

julia> map(P,1)
Rg^5 -> Rg^2
e[1] -> x*e[1]
e[2] -> -y*e[1] + x*e[2]
e[3] -> y^2*e[2]
e[4] -> z^4*e[1]
e[5] -> z^4*e[2]
Homogeneous module homomorphism
```
"""
function presentation(M::ModuleFP)
 error("presentation is not implemented for the given types.")
end

@doc raw"""
    present_as_cokernel(M::SubquoModule, task::Symbol = :none)

Return a subquotient `C` which is isomorphic to `M`, and whose generators are the standard unit vectors of its ambient free module.

Additionally,

- return an isomorphism `M` $\to$ `C` if `task = :with_morphism`,
- return and cache an isomorphism `M` $\to$ `C` if `task = :cache_morphism`,
- do none of the above if `task = :none` (default).

If `task = :only_morphism`, return only an isomorphism.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> A = R[x; y];

julia> B = R[x^2; y^3; z^4];

julia> M = SubquoModule(A, B)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> C = present_as_cokernel(M)
Subquotient of Submodule with 2 generators
1 -> e[1]
2 -> e[2]
by Submodule with 5 generators
1 -> x*e[1]
2 -> -y*e[1] + x*e[2]
3 -> y^2*e[2]
4 -> z^4*e[1]
5 -> z^4*e[2]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 1);

julia> A = Rg[x; y];

julia> B = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, A, B);

julia> present_as_cokernel(M, :with_morphism)
(Graded subquotient of submodule of Rg^2 generated by
1 -> e[1]
2 -> e[2]
by submodule of Rg^2 generated by
1 -> x*e[1]
2 -> -y*e[1] + x*e[2]
3 -> y^2*e[2]
4 -> z^4*e[1]
5 -> z^4*e[2], Graded subquotient of submodule of Rg^2 generated by
1 -> e[1]
2 -> e[2]
by submodule of Rg^2 generated by
1 -> x*e[1]
2 -> -y*e[1] + x*e[2]
3 -> y^2*e[2]
4 -> z^4*e[1]
5 -> z^4*e[2] -> M
e[1] -> x*e[1]
e[2] -> y*e[1]
Homogeneous module homomorphism)
```
"""
function present_as_cokernel(SQ::SubquoModule, task::Symbol = :none)
  chainComplex = presentation(SQ)
  R_b = obj(chainComplex, 0)
  f = map(chainComplex, 1)
  g = map(chainComplex, 0)
  presentation_module = quo(R_b, image(f)[1], :module)

  if task == :none
    return presentation_module
  end
  
  # The isomorphism is just the identity matrix
  isomorphism = hom(presentation_module, SQ, Vector{elem_type(SQ)}([g(x) for x in gens(R_b)]))
  inverse_isomorphism = hom(SQ, presentation_module, Vector{elem_type(presentation_module)}([presentation_module[i] for i=1:ngens(SQ)]))
  isomorphism.inverse_isomorphism = inverse_isomorphism

  if task == :cache_morphism
    register_morphism!(isomorphism)
    register_morphism!(inverse_isomorphism)
  end
  task == :only_morphism && return isomorphism
  
  return presentation_module, isomorphism
end

@doc raw"""
    present_as_cokernel(F::FreeMod, task::Symbol = :none)

Represent `F` as the quotient `C` of itself with no relations. This method exists for compatibility reasons with `present_as_cokernel(M::SubQuoModule, task::Symbol = :none)`. 

Additionally,

- return an isomorphism `F` $\to$ `C` if `task = :with_morphism`,
- return and cache an isomorphism `F` $\to$ `C` if `task = :cache_morphism`,
- do none of the above if `task = :none` (default).

If `task = :only_morphism`, return only an isomorphism.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = free_module(R, 2)
Free module of rank 2 over Multivariate polynomial ring in 3 variables over QQ

julia> present_as_cokernel(F)
Submodule with 2 generators
1 -> e[1]
2 -> e[2]
represented as subquotient with no relations.

julia> present_as_cokernel(F, :only_morphism)
Map with following data
Domain:
=======
Free module of rank 2 over Multivariate polynomial ring in 3 variables over QQ
Codomain:
=========
Submodule with 2 generators
1 -> e[1]
2 -> e[2]
represented as subquotient with no relations.
```
"""
function present_as_cokernel(F::FreeMod, task::Symbol = :none)
  presentation_module, isomorphism = quo(F, [zero(F)])
  inverse_isomorphism = hom(presentation_module, F, gens(F))

  if task == :none
    return presentation_module
  end

  if task == :cache_morphism
    register_morphism!(isomorphism)
    register_morphism!(inverse_isomorphism)
  end
  task == :only_morphism && return isomorphism
  
  return presentation_module, isomorphism
end

@doc raw"""
    hom_tensor(M::ModuleFP, N::ModuleFP, V::Vector{<:ModuleFPHom})

Given modules `M`, `N` which are tensor products with the same number of factors,
say $M = M_1 \otimes \cdots \otimes M_r$, $N = N_1 \otimes \cdots \otimes N_r$,
and given a vector `V` of homomorphisms $a_i : M_i \to N_i$, return 
$a_1 \otimes \cdots \otimes a_r$.
"""
function hom_tensor(M::ModuleFP, N::ModuleFP, V::Vector{ <: ModuleFPHom})
  tM = get_attribute(M, :tensor_product)
  tM === nothing && error("both modules must be tensor products")
  tN = get_attribute(N, :tensor_product)
  tN === nothing && error("both modules must be tensor products")
  @assert length(tM) == length(tN) == length(V)
  @assert all(i-> domain(V[i]) === tM[i] && codomain(V[i]) === tN[i], 1:length(V))
  #gens of M are M[i][j] tensor M[h][l] for i != h and all j, l
  #such a pure tensor is mapped to V[i](M[i][j]) tensor V[h](M[j][l])
  #thus need the pure map - and re-create the careful ordering of the generators as in the 
  # constructor
  #store the maps? and possibly more data, like the ordeing
  decompose_M = get_attribute(M, :tensor_generator_decompose_function)
  pure_N = get_attribute(N, :tensor_pure_function)
  function map_gen(g) # Is there something that generalizes FreeModElem and SubquoModuleElem?
    g_decomposed = decompose_M(g)
    image_as_tuple = Tuple(f(x) for (f,x) in zip(V,g_decomposed))
    res = pure_N(image_as_tuple)
    return res
  end
  return hom(M, N, Vector{elem_type(N)}(map(map_gen, gens(M))))
end

@doc raw"""
    hom_product(M::ModuleFP, N::ModuleFP, A::Matrix{<:ModuleFPHom})

Given modules `M` and `N` which are products with `r` respective `s` factors,  
say $M = \prod_{i=1}^r M_i$, $N = \prod_{j=1}^s N_j$, and given a $r \times s$ matrix 
`A` of homomorphisms $a_{ij} : M_i \to N_j$, return the homomorphism
$M \to N$ with $ij$-components $a_{ij}$.
"""
function hom_product(M::ModuleFP, N::ModuleFP, A::Matrix{<:ModuleFPHom})
  tM = get_attribute(M, :direct_product)
  tM === nothing && error("both modules must be direct products")
  tN = get_attribute(N, :direct_product)
  tN === nothing && error("both modules must be direct products")
  @assert length(tM) == size(A, 1) && length(tN) == size(A, 2)
  @assert all(ij -> domain(A[ij[1],ij[2]]) === tM[ij[1]] && codomain(A[ij[1],ij[2]]) === tN[ij[2]], Base.Iterators.ProductIterator((1:size(A, 1), 1:size(A, 2))))
  #need the canonical maps..., maybe store them as well?
  return hom(M,N,Vector{elem_type(N)}([sum([canonical_injection(N,j)(sum([A[i,j](canonical_projection(M,i)(g)) for i=1:length(tM)])) for j=1:length(tN)]) for g in gens(M)]))
end
# hom(prod -> X), hom(x -> prod)
# if too much time: improve the hom(A, B) in case of A and/or B are products - or maybe not...
# tensor and hom functors for chain complex
# dual: ambig: hom(M, R) or hom(M, Q(R))?

function lift_with_unit(a::FreeModElem{T}, generators::ModuleGens{T}) where {T <: MPolyRingElem}
  # TODO allow optional argument ordering
  # To do this efficiently we need better infrastructure in Singular.jl
  R = base_ring(parent(a))
  singular_assure(generators)
  if Singular.has_global_ordering(base_ring(generators.SF))
    l = lift(a, generators)
    return l, R(1)
  end
  error("Not implemented")
end

function map(FR::FreeResolution, i::Int)
  return map(FR.C, i)
end

function free_show(io::IO, C::ComplexOfMorphisms)
  Cn = get_attribute(C, :name)
  if Cn === nothing
    Cn = "F"
  end

  name_mod = String[]
  rank_mod = Int[]

  rng = range(C)
  rng = first(rng):-1:0
  arr = ("<--", "--")

  R = Nemo.base_ring(C[first(rng)])
  R_name = get_attribute(R, :name)
  if R_name === nothing
    R_name = AbstractAlgebra.find_name(R)
    if R_name === nothing
      R_name = "$R"
    end
  end
 
  for i=reverse(rng)
    M = C[i]
    if get_attribute(M, :name) !== nothing
      push!(name_mod, get_attribute(M, :name))
    elseif AbstractAlgebra.find_name(M) !== nothing
      push!(name_mod, AbstractAlgebra.find_name(M) )
    else
      push!(name_mod, "$R_name^$(rank(M))")
    end
    push!(rank_mod, rank(M))
  end

  io = IOContext(io, :compact => true)
  N = get_attribute(C, :free_res)
  if N !== nothing
    print(io, "Free resolution")
    print(io, " of ", N)
  end
  print(io, "\n")

  pos = 0
  pos_mod = Int[]
  
  for i=1:length(name_mod)
    print(io, name_mod[i])
    push!(pos_mod, pos)
    pos += length(name_mod[i])
    if i < length(name_mod)
      print(io, " ", arr[1], arr[2], " ")
      pos += length(arr[1]) + length(arr[2]) + 2
    end
  end

  print(io, "\n")
  len = 0
  for i=1:length(name_mod)
    if i>1
      print(io, " "^(pos_mod[i] - pos_mod[i-1]-len))
    end
    print(io, reverse(rng)[i])
    len = length("$(reverse(rng)[i])")
  end
#  print(io, "\n")
end


@doc raw"""
    free_resolution(F::FreeMod)

Return a free resolution of `F`. The `length` and `algorithm`
keywords are here only for compatibility reasons with the other `free_resolution`
methods and have no effect on the computation.

# Examples
"""
function free_resolution(F::FreeMod; length::Int=0, algorithm::Symbol=:fres)
  res = presentation(F)
  set_attribute!(res, :show => free_show, :free_res => F)
  return FreeResolution(res)
end

@doc raw"""
    is_complete(FR::FreeResolution)

Return `true` if the free resolution `fr` is complete, otherwise return `false`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> A = R[x; y]
[x]
[y]

julia> B = R[x^2; x*y; y^2; z^4]
[x^2]
[x*y]
[y^2]
[z^4]

julia> M = SubquoModule(A, B)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 4 generators
1 -> x^2*e[1]
2 -> x*y*e[1]
3 -> y^2*e[1]
4 -> z^4*e[1]

julia> fr = free_resolution(M, length=1)
Free resolution of M
R^2 <---- R^6
0         1

julia> is_complete(fr)
false

julia> fr = free_resolution(M)
Free resolution of M
R^2 <---- R^6 <---- R^6 <---- R^2 <---- 0
0         1         2         3         4

julia> is_complete(fr)
true

```
"""
is_complete(FR::FreeResolution) = FR.C.complete

function chain_range(FR::FreeResolution)
  return Hecke.range(FR.C)
end

function map_range(FR::FreeResolution)
  return Hecke.map_range(FR.C)
end

function chain_range(C::ComplexOfMorphisms)
  return Hecke.range(C)
end

function map_range(C::ComplexOfMorphisms)
  return Hecke.map_range(C)
end


#= Fill functions (and helpers) for Hecke ComplexOfMorphismses in terms of free resolutions =#
function _get_last_map_key(cc::Hecke.ComplexOfMorphisms)
  return last(Hecke.map_range(cc))
end

function _extend_free_resolution(cc::Hecke.ComplexOfMorphisms, idx::Int)
# assuming a free res is a chain_complex, then it will be
# M_1 -> M_0 -> S -> 0
#the range is 1:-1:-2 or so
#thus
# - extending right is trivial - and doing zero only
# - extending lift is repeated pushfirst
# - the idx is only used to see how many maps are missing

  algorithm = get_attribute(cc, :algorithm)
  if algorithm === nothing
    algorithm = :fres
    set_attribute!(cc, :algorithm, :fres)
  end
  r = Hecke.map_range(cc)
  if idx < last(r)
    error("extending past the final zero not supported")
  end
  len_missing = idx - first(r)
  @assert len_missing > 0
  if cc.complete == true
    return map(cc, first(r))
  end

  kernel_entry          = image(cc.maps[1])[1]
  br                    = base_ring(kernel_entry)
  singular_free_module  = singular_module(ambient_free_module(kernel_entry))
  singular_kernel_entry = Singular.Module(base_ring(singular_free_module),
                              [singular_free_module(repres(g)) for g in gens(kernel_entry)]...)
  singular_kernel_entry.isGB = true

  len = len_missing + 1
  if algorithm == :fres
    res = Singular.fres(singular_kernel_entry, len, "complete")
  elseif algorithm == :lres
    error("LaScala's method is not yet available in Oscar.")
  elseif algorithm == :mres
    res = Singular.mres(singular_kernel_entry, len)
  elseif algorithm == :nres
    res = Singular.nres(singular_kernel_entry, len)
  else
    error("Unsupported algorithm $algorithm")
  end

  dom = domain(cc.maps[1])
  j   = 2

  while j <= Singular.length(res)
    rk = Singular.ngens(res[j])
    if is_graded(dom)
      codom = dom
      SM    = SubModuleOfFreeModule(codom, res[j])
      generator_matrix(SM)
      map = graded_map(codom, SM.matrix)
      dom = domain(map)
      set_attribute!(dom, :name => "R^$rk")
    else
      codom = dom
      dom   = free_module(br, Singular.ngens(res[j]))
      SM    = SubModuleOfFreeModule(codom, res[j])
      set_attribute!(dom, :name => "R^$rk")
      generator_matrix(SM)
      map = hom(dom, codom, SM.matrix)
    end
    pushfirst!(cc, map) 
    j += 1
  end
  # Finalize maps.
  if Singular.length(res) < len
    Z = FreeMod(br, 0)
    set_attribute!(Z, :name => "0")
    pushfirst!(cc, hom(Z, domain(cc.maps[1]), Vector{elem_type(domain(cc.maps[1]))}()))
    cc.complete = true
  end
  set_attribute!(cc, :show => free_show)
  maxidx = min(idx, first(Hecke.map_range(cc)))
  return map(cc, maxidx)
end

@doc raw"""
    free_resolution(M::SubquoModule{<:MPolyRingElem}; 
        ordering::ModuleOrdering = default_ordering(M),
        length::Int=0, algorithm::Symbol=:fres
      )

Return a free resolution of `M`.

If `length != 0`, the free resolution is only computed up to the `length`-th free module.
At the moment, options for `algorithm` are `:fres`, `:mres` and `:nres`. With `:mres` or `:nres`,
minimal free resolutions are returned.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> A = R[x; y]
[x]
[y]

julia> B = R[x^2; x*y; y^2; z^4]
[x^2]
[x*y]
[y^2]
[z^4]

julia> M = SubquoModule(A, B)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 4 generators
1 -> x^2*e[1]
2 -> x*y*e[1]
3 -> y^2*e[1]
4 -> z^4*e[1]

julia> fr = free_resolution(M, length=1)
Free resolution of M
R^2 <---- R^6
0         1

julia> is_complete(fr)
false

julia> fr[4]
Free module of rank 0 over Multivariate polynomial ring in 3 variables over QQ

julia> fr
Free resolution of M
R^2 <---- R^6 <---- R^6 <---- R^2 <---- 0
0         1         2         3         4

julia> is_complete(fr)
true

julia> fr = free_resolution(M, algorithm=:fres)
Free resolution of M
R^2 <---- R^6 <---- R^6 <---- R^2 <---- 0
0         1         2         3         4
```

**Note:** Over rings other than polynomial rings, the method will default to a lazy, 
iterative kernel computation.
"""
function free_resolution(M::SubquoModule{<:MPolyRingElem}; 
                         ordering::ModuleOrdering = default_ordering(M),
                         length::Int=0, algorithm::Symbol=:fres)

  coefficient_ring(base_ring(M)) isa AbstractAlgebra.Field ||
      error("Must be defined over a field.")

  cc_complete = false

  #= Start with presentation =#
  pm = presentation(M)
  maps = [pm.maps[j] for j in 2:3]

  br = base_ring(M)
  kernel_entry          = image(pm.maps[1])[1]

  if ngens(kernel_entry) == 0
    cc = Hecke.ComplexOfMorphisms(Oscar.ModuleFP, pushfirst!(maps, pm.maps[1]), check = false, seed = -2)
    cc.fill     = _extend_free_resolution
    cc.complete = true
    return FreeResolution(cc)
  end

  singular_free_module  = singular_module(ambient_free_module(kernel_entry))
  singular_kernel_entry = Singular.Module(base_ring(singular_free_module),
                              [singular_free_module(repres(g)) for g in gens(kernel_entry)]...)

  #= This is the single computational hard part of this function =#
  if algorithm == :fres
    gbpres = Singular.std(singular_kernel_entry)
    res = Singular.fres(gbpres, length, "complete")
  elseif algorithm == :lres
    error("LaScala's method is not yet available in Oscar.")
    gbpres = singular_kernel_entry # or as appropriate, taking into account base changes
  elseif algorithm == :mres
    gbpres = singular_kernel_entry
    res = Singular.mres(gbpres, length)
  elseif algorithm == :nres
    gbpres = singular_kernel_entry
    res = Singular.nres(gbpres, length)
  else
    error("Unsupported algorithm $algorithm")
  end

  if length == 0 || Singular.length(res) < length
    cc_complete = true
  end

  br_name = AbstractAlgebra.find_name(base_ring(M))
  if br_name === nothing
    br_name = "R"
  end

  #= Add maps from free resolution computation, start with second entry
   = due to inclusion of presentation(M) at the beginning. =#
  j   = 1
  while j <= Singular.length(res)
    if is_graded(M)
      codom = domain(maps[1])
      rk    = Singular.ngens(res[j])
      SM    = SubModuleOfFreeModule(codom, res[j])
      generator_matrix(SM)
      ff = graded_map(codom, SM.matrix)
      dom = domain(ff)
      set_attribute!(dom, :name => "$br_name^$rk")
      insert!(maps, 1, ff)
      j += 1
    else
      codom = domain(maps[1])
      rk    = Singular.ngens(res[j])
      dom   = free_module(br, rk)
      SM    = SubModuleOfFreeModule(codom, res[j])
      generator_matrix(SM)
      set_attribute!(dom, :name => "$br_name^$rk")
      insert!(maps, 1, hom(dom, codom, SM.matrix))
      j += 1
    end
  end
  if cc_complete == true
    # Finalize maps.
    if is_graded(domain(maps[1]))
      Z = graded_free_module(br, 0)
    else
      Z = FreeMod(br, 0)
    end
    set_attribute!(Z, :name => "0")
    insert!(maps, 1, hom(Z, domain(maps[1]), Vector{elem_type(domain(maps[1]))}()))
  end

  cc = Hecke.ComplexOfMorphisms(Oscar.ModuleFP, maps, check = false, seed = -2)
  cc.fill     = _extend_free_resolution
  cc.complete = cc_complete
  set_attribute!(cc, :show => free_show, :free_res => M)
  set_attribute!(cc, :algorithm, algorithm)

  return FreeResolution(cc)
end

function free_resolution(M::SubquoModule{T}) where {T<:RingElem}
  # This generic code computes a free resolution in a lazy way.
  # We start out with a presentation of M and implement 
  # an iterative fill function to compute every higher term 
  # on request.
  R = base_ring(M)
  p = presentation(M)
  p.fill = function(C::Hecke.ComplexOfMorphisms, k::Int)
    # TODO: Use official getter and setter methods instead 
    # of messing manually with the internals of the complex.
    for i in first(chain_range(C)):k-1
      N = domain(map(C, i))

      if iszero(N) # Fill up with zero maps
        C.complete = true
        phi = hom(N, N, elem_type(N)[])
        pushfirst!(C.maps, phi)
        continue
      end

      K, inc = kernel(map(C, i))
      nz = findall(x->!iszero(x), gens(K))
      F = FreeMod(R, length(nz))
      iszero(length(nz)) && set_attribute!(F, :name => "0")
      phi = hom(F, C[i], iszero(length(nz)) ? elem_type(C[i])[] : inc.(gens(K)[nz]))
      pushfirst!(C.maps, phi)
    end
    return first(C.maps)
  end
  return p
end


@doc raw"""
    free_resolution_via_kernels(M::SubquoModule, limit::Int = -1)

Return a free resolution of `M`.

If `limit != -1`, the free resolution
is only computed up to the `limit`-th free module.

# Examples
"""
function free_resolution_via_kernels(M::SubquoModule, limit::Int = -1)
  p = presentation(M)
  mp = [map(p, j) for j in Hecke.map_range(p)]  
  while true
    k, mk = kernel(mp[1])
    nz = findall(x->!iszero(x), gens(k))
    if length(nz) == 0 
      if is_graded(domain(mp[1]))
        h = graded_map(domain(mp[1]), Vector{elem_type(domain(mp[1]))}())
      else
        Z = FreeMod(base_ring(M), 0)
        set_attribute!(Z, :name => "0")
        h = hom(Z, domain(mp[1]), Vector{elem_type(domain(mp[1]))}())
      end
      insert!(mp, 1, h)
      break
    elseif limit != -1 && length(mp) > limit
      break
    end
    if is_graded(codomain(mk))
      g = graded_map(codomain(mk), collect(k.sub.gens)[nz])
    else
      F = FreeMod(base_ring(M), length(nz))
      g = hom(F, codomain(mk), collect(k.sub.gens)[nz])
    end
    insert!(mp, 1, g)
  end
  C = Hecke.ComplexOfMorphisms(ModuleFP, mp, check = false, seed = -2)
  #set_attribute!(C, :show => free_show, :free_res => M) # doesn't work
  return FreeResolution(C)
end

@doc raw"""
    free_resolution(I::MPolyIdeal; length::Int=0, algorithm::Symbol=:fres)

Compute a free resolution of `I`.

If `length != 0`, the free resolution is only computed up to the `length`-th free module.
At the moment, options for `algorithm` are `:fres`, `:mres` and `:nres`. With `:mres` or `:nres`,
minimal free resolutions are returned.

# Examples
"""
function free_resolution(I::MPolyIdeal;
                         length::Int=0, algorithm::Symbol=:fres)
  S = ideal_as_module(I)
  n = Hecke.find_name(I)
  if n !== nothing
    AbstractAlgebra.set_name!(S, string(n))
  end
  return free_resolution(S, length = length, algorithm = algorithm)
end

@doc raw"""
    free_resolution(Q::MPolyQuoRing; length::Int=0, algorithm::Symbol=:fres)

Compute a free resolution of `Q`.

If `length != 0`, the free resolution is only computed up to the `length`-th free module.
At the moment, options for `algorithm` are `:fres`, `:mres` and `:nres`. With `:mres` or `:nres`,
minimal free resolutions are returned.

# Examples
"""
function free_resolution(Q::MPolyQuoRing;
                         length::Int=0, algorithm::Symbol=:fres)
  q = quotient_ring_as_module(Q)
  n = Hecke.find_name(Q)
  if n !== nothing
    AbstractAlgebra.set_name!(q, String(n))
  end
  return free_resolution(q, length = length, algorithm = algorithm)
end

#############################
# Tor
#############################
@doc raw"""
    tensor_product(M::ModuleFP, C::ComplexOfMorphisms{ModuleFP})

Return the complex obtained by applying `M` $\otimes\;\! \bullet$ to `C`.
"""
function tensor_product(P::ModuleFP, C::Hecke.ComplexOfMorphisms{ModuleFP})
  #tensor_chain = Hecke.map_type(C)[]
  tensor_chain = valtype(C.maps)[]
  tensor_modules = [tensor_product(P, domain(map(C,first(chain_range(C)))), task=:cache_morphism)[1]]
  append!(tensor_modules, [tensor_product(P, codomain(map(C,i)), task=:cache_morphism)[1] for i in Hecke.map_range(C)])

  for i in 1:length(Hecke.map_range(C))
    A = tensor_modules[i]
    B = tensor_modules[i+1]

    j = Hecke.map_range(C)[i]
    push!(tensor_chain, hom_tensor(A,B,[identity_map(P), map(C,j)]))
  end

  return Hecke.ComplexOfMorphisms(ModuleFP, tensor_chain, seed=C.seed, typ=C.typ)
end

function tensor_product(M::ModuleFP, F::FreeResolution)
  return tensor_product(M, F.C)
end


@doc raw"""
    tensor_product(C::ComplexOfMorphisms{<:ModuleFP}, M::ModuleFP)

Return the complex obtained by applying $\bullet\;\! \otimes$ `M` to `C`.
"""
function tensor_product(C::Hecke.ComplexOfMorphisms{<:ModuleFP}, P::ModuleFP)
  #tensor_chain = Hecke.map_type(C)[]
  tensor_chain = valtype(C.maps)[]
  tensor_chain = Map[]
  chain_range = Hecke.map_range(C)
  tensor_modules = [tensor_product(domain(map(C,first(chain_range))), P, task=:cache_morphism)[1]]
  append!(tensor_modules, [tensor_product(codomain(map(C,i)), P, task=:cache_morphism)[1] for i in chain_range])

  for i=1:length(chain_range)
    A = tensor_modules[i]
    B = tensor_modules[i+1]

    j = chain_range[i]
    push!(tensor_chain, hom_tensor(A,B,[map(C,j), identity_map(P)]))
  end

  return Hecke.ComplexOfMorphisms(ModuleFP, tensor_chain, seed=C.seed, typ=C.typ)
end

function tensor_product(F::FreeResolution, M::ModuleFP)
  return tensor_product(F.C, M)
end

@doc raw"""
    tor(M::ModuleFP, N::ModuleFP, i::Int)

Return $\text{Tor}_i(M,N)$.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> A = R[x; y];

julia> B = R[x^2; y^3; z^4];

julia> M = SubquoModule(A, B);

julia> F = free_module(R, 1);

julia> Q, _ = quo(F, [x*F[1]]);

julia> T0 = tor(Q, M, 0)
Subquotient of Submodule with 2 generators
1 -> x*e[1] \otimes e[1]
2 -> y*e[1] \otimes e[1]
by Submodule with 4 generators
1 -> x^2*e[1] \otimes e[1]
2 -> y^3*e[1] \otimes e[1]
3 -> z^4*e[1] \otimes e[1]
4 -> x*y*e[1] \otimes e[1]

julia> T1 = tor(Q, M, 1)
Subquotient of Submodule with 1 generator
1 -> -x*e[1] \otimes e[1]
by Submodule with 3 generators
1 -> x^2*e[1] \otimes e[1]
2 -> y^3*e[1] \otimes e[1]
3 -> z^4*e[1] \otimes e[1]

julia> T2 =  tor(Q, M, 2)
Submodule with 0 generators
represented as subquotient with no relations.
```
"""
function tor(M::ModuleFP, N::ModuleFP, i::Int)
  free_res = free_resolution(M; length=i+2)
  lifted_resolution = tensor_product(free_res.C[first(chain_range(free_res.C)):-1:1], N) #TODO only three homs are necessary
  return simplify_light(homology(lifted_resolution,i))[1]
end

simplify_light(F::FreeMod) = F

#TODO, mF
#  (hom lift) => hom and tensor functor
#  filtrations
#  more constructors
#################################################
#
#################################################
@doc raw"""
    lift_homomorphism_contravariant(Hom_MP::ModuleFP, Hom_NP::ModuleFP, a::ModuleFPHom)

Given modules of homomorphism, say, `Hom_MP` $= \text{Hom}(M,P)$ and `Hom_NP` $= \text{Hom}(N,P)$, 
and given a homomorphism `a` $: N \to M$, return the induced homomorphism
$\text{Hom}(M,P) \to \text{Hom}(N,P)$.
"""
function lift_homomorphism_contravariant(Hom_MP::ModuleFP, Hom_NP::ModuleFP, phi::ModuleFPHom)
  # phi : N -> M
  M_P = get_attribute(Hom_MP, :hom)
  M_P === nothing && error("Both modules must be hom modules")
  N_P = get_attribute(Hom_NP, :hom)
  N_P === nothing && error("Both modules must be hom modules")
  
  @assert M_P[2] === N_P[2]
  M,P = M_P
  N,_ = N_P
  @assert domain(phi) === N
  @assert codomain(phi) === M
  
  phi_lifted = hom(Hom_MP, Hom_NP, Vector{elem_type(Hom_NP)}([homomorphism_to_element(Hom_NP, phi*element_to_homomorphism(f)) for f in gens(Hom_MP)]))
  return phi_lifted
end

@doc raw"""
    lift_homomorphism_covariant(Hom_PM::ModuleFP, Hom_PN::ModuleFP, a::ModuleFPHom)

Given modules of homomorphism, say, `Hom_PM` $= \text{Hom}(P,M)$ and `Hom_PN` $= \text{Hom}(P,N)$,
and given a homomorphism `a` $: M \to N$, return the induced homomorphism
$\text{Hom}(P,M) \to \text{Hom}(P,N)$.
"""
function lift_homomorphism_covariant(Hom_PM::ModuleFP, Hom_PN::ModuleFP, phi::ModuleFPHom)
  # phi : M -> N
  P_M = get_attribute(Hom_PM, :hom)
  P_M === nothing && error("Both modules must be hom modules")
  P_N = get_attribute(Hom_PN, :hom)
  P_N === nothing && error("Both modules must be hom modules")

  @assert P_M[1] === P_N[1]
  P,M = P_M
  _,N = P_N
  @assert domain(phi) === M
  @assert codomain(phi) === N

  if iszero(Hom_PN)
    return hom(Hom_PM, Hom_PN, Vector{elem_type(Hom_PN)}([zero(Hom_PN) for _=1:ngens(Hom_PM)]))
  end
  phi_lifted = hom(Hom_PM, Hom_PN, Vector{elem_type(Hom_PN)}([homomorphism_to_element(Hom_PN, element_to_homomorphism(f)*phi) for f in gens(Hom_PM)]))
  return phi_lifted
end

@doc raw"""
    hom(M::ModuleFP, C::ComplexOfMorphisms{ModuleFP})

Return the complex obtained by applying $\text{Hom}($`M`, $-)$ to `C`.
"""
function hom(P::ModuleFP, C::Hecke.ComplexOfMorphisms{ModuleFP})
  #hom_chain = Hecke.map_type(C)[]
  hom_chain = valtype(C.maps)[]
  chain_range = Hecke.map_range(C)
  hom_modules = [hom(P, domain(map(C,first(chain_range))))]
  append!(hom_modules, [hom(P, codomain(map(C,i))) for i in chain_range])

  for i=1:length(chain_range)
    A = hom_modules[i][1]
    B = hom_modules[i+1][1]

    j = chain_range[i]
    push!(hom_chain, lift_homomorphism_covariant(A,B,map(C,j)))
  end

  return Hecke.ComplexOfMorphisms(ModuleFP, hom_chain, seed=C.seed, typ=C.typ)
end

function hom(M::ModuleFP, F::FreeResolution)
  return hom(M, F.C)
end

@doc raw"""
    hom(C::ComplexOfMorphisms{ModuleFP}, M::ModuleFP)

Return the complex obtained by applying $\text{Hom}(-,$ `M`$)$ to `C`.

If `C` is a chain complex, return a cochain complex.
If `C` is a cochain complex, return a chain complex.

# Examples
```jldoctest
julia> R, (x,) = polynomial_ring(QQ, ["x"]);

julia> F = free_module(R, 1);

julia> A, _ = quo(F, [x^4*F[1]]);

julia> B, _ = quo(F, [x^3*F[1]]);

julia> a = hom(A, B, [x^2*B[1]]);

julia> b = hom(B, B, [x^2*B[1]]);

julia> C = chain_complex([a, b]; seed = 3);

julia> range(C)
5:-1:3

julia> D = hom(C, A);

julia> range(D)
3:5
```
"""
function hom(C::Hecke.ComplexOfMorphisms{ModuleFP}, P::ModuleFP)
  #hom_chain = Hecke.map_type(C)[]
  hom_chain = valtype(C.maps)[]
  hom_chain = Map[]
  chain_range = Hecke.map_range(C)
  hom_modules = [hom(domain(map(C,first(chain_range))),P)]
  append!(hom_modules, [hom(codomain(map(C,i)), P) for i in chain_range])

  for i=1:length(chain_range)
    A = hom_modules[i][1]
    B = hom_modules[i+1][1]

    j = chain_range[i]
    push!(hom_chain, lift_homomorphism_contravariant(B,A,map(C,j)))
  end

  typ = Hecke.is_chain_complex(C) ? :cochain : :chain
  seed = C.seed
  return Hecke.ComplexOfMorphisms(ModuleFP, reverse(hom_chain), seed=seed, typ=typ)
end

function hom(F::FreeResolution, M::ModuleFP)
  return hom(F.C, M)
end

@doc raw"""
    hom_without_reversing_direction(C::ComplexOfMorphisms{ModuleFP}, M::ModuleFP)

Return the complex obtained by applying $\text{Hom}(-,$ `M`$)$ to `C`.

If `C` is a chain complex, return a chain complex.
If `C` is a cochain complex, return a cochain complex.

# Examples
```jldoctest
julia> R, (x,) = polynomial_ring(QQ, ["x"]);

julia> F = free_module(R, 1);

julia> A, _ = quo(F, [x^4*F[1]]);

julia> B, _ = quo(F, [x^3*F[1]]);

julia> a = hom(A, B, [x^2*B[1]]);

julia> b = hom(B, B, [x^2*B[1]]);

julia> C = chain_complex([a, b]; seed = 3);

julia> range(C)
5:-1:3

julia> D = hom_without_reversing_direction(C, A);

julia> range(D)
-3:-1:-5
```
"""
function hom_without_reversing_direction(C::Hecke.ComplexOfMorphisms{ModuleFP}, P::ModuleFP)
  #up to seed/ typ identical to the one above. Should be
  #ONE worker function with 2 interfaces.
  #hom_chain = Hecke.map_type(C)[]
  hom_chain = valtype(C.maps)[]
  m_range = Hecke.map_range(C)
  hom_modules = [hom(domain(map(C,first(m_range))),P)]
  append!(hom_modules, [hom(codomain(map(C,i)), P) for i in m_range])

  for i=1:length(m_range)
    A = hom_modules[i][1]
    B = hom_modules[i+1][1]

    j = m_range[i]
    push!(hom_chain, lift_homomorphism_contravariant(B,A,map(C,j)))
  end

  return Hecke.ComplexOfMorphisms(ModuleFP, reverse(hom_chain), seed=-first(chain_range(C)), typ=C.typ)
end

function hom_without_reversing_direction(F::FreeResolution, M::ModuleFP)
  return hom_without_reversing_direction(F.C, M)
end


#############################
@doc raw"""
    homology(C::ComplexOfMorphisms{<:ModuleFP})

Return the homology of `C`.

# Examples
```jldoctest
julia> R, (x,) = polynomial_ring(QQ, ["x"]);

julia> F = free_module(R, 1);

julia> A, _ = quo(F, [x^4*F[1]]);

julia> B, _ = quo(F, [x^3*F[1]]);

julia> a = hom(A, B, [x^2*B[1]]);

julia> b = hom(B, B, [x^2*B[1]]);

julia> C = ComplexOfMorphisms(ModuleFP, [a, b]);

julia> H = homology(C)
3-element Vector{SubquoModule{QQMPolyRingElem}}:
 Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 1 generator
1 -> x^4*e[1]
 Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 2 generators
1 -> x^3*e[1]
2 -> x^2*e[1]
 Subquotient of Submodule with 1 generator
1 -> e[1]
by Submodule with 2 generators
1 -> x^3*e[1]
2 -> x^2*e[1]
```
"""
function homology(C::Hecke.ComplexOfMorphisms{<:ModuleFP})
  return [homology(C,i) for i in Hecke.range(C)]
end

function homology(C::FreeResolution)
  return homology(C.C)
end


@doc raw"""
    homology(C::ComplexOfMorphisms{<:ModuleFP}, i::Int)

Return the `i`-th homology module of `C`.

# Examples
```jldoctest
julia> R, (x,) = polynomial_ring(QQ, ["x"]);

julia> F = free_module(R, 1);

julia> A, _ = quo(F, [x^4*F[1]]);

julia> B, _ = quo(F, [x^3*F[1]]);

julia> a = hom(A, B, [x^2*B[1]]);

julia> b = hom(B, B, [x^2*B[1]]);

julia> C = ComplexOfMorphisms(ModuleFP, [a, b]);

julia> H = homology(C, 1)
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 2 generators
1 -> x^3*e[1]
2 -> x^2*e[1]
```
"""
function homology(C::Hecke.ComplexOfMorphisms{<:ModuleFP}, i::Int)
  chain_range = Hecke.range(C)
  map_range = Hecke.map_range(C)
  @assert length(chain_range) > 0 #TODO we need actually only the base ring
  if i == first(chain_range)
    return kernel(map(C, first(map_range)))[1]
  elseif i == last(chain_range)
    f = map(C,last(map_range))
    return cokernel(f)    
  elseif i in chain_range
    if Hecke.is_chain_complex(C)
      return quo(kernel(map(C,i))[1], image(map(C,i+1))[1], :module)
    else
      return quo(kernel(map(C,i))[1], image(map(C,i-1))[1], :module)
    end
  else
    return FreeMod(base_ring(obj(C,first(chain_range))),0)
  end
end

#############################
# Ext
#############################
@doc raw"""
    ext(M::ModuleFP, N::ModuleFP, i::Int)

Return $\text{Ext}^i(M,N)$.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"]);

julia> F = FreeMod(R, 1);

julia> V = [x*F[1], y*F[1]];

julia> M = quo(F, V)[1]
Subquotient of Submodule with 1 generator
1 -> e[1]
by Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]

julia> ext(M, M, 0)
Subquotient of Submodule with 1 generator
1 -> (e[1] -> e[1])
by Submodule with 2 generators
1 -> x*(e[1] -> e[1])
2 -> y*(e[1] -> e[1])

julia> ext(M, M, 1)
Subquotient of Submodule with 2 generators
1 -> (e[2] -> e[1])
2 -> (e[1] -> e[1])
by Submodule with 4 generators
1 -> x*(e[1] -> e[1])
2 -> y*(e[1] -> e[1])
3 -> x*(e[2] -> e[1])
4 -> y*(e[2] -> e[1])

julia> ext(M, M, 2)
Subquotient of Submodule with 1 generator
1 -> (e[1] -> e[1])
by Submodule with 3 generators
1 -> x*(e[1] -> e[1])
2 -> y*(e[1] -> e[1])
3 -> -x*(e[1] -> e[1])

julia> ext(M, M, 3)
Submodule with 0 generators
represented as subquotient with no relations.
```
"""
function ext(M::ModuleFP, N::ModuleFP, i::Int)
  free_res = free_resolution(M; length=i+2)
  
  lifted_resolution = hom(free_res.C[first(Hecke.map_range(free_res.C)):-1:1], N) #TODO only three homs are necessary
  return simplify_light(homology(lifted_resolution,i))[1]
end

